<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spinning 3D Earth</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://threejs.org/build/three.js"></script>

    <script>
        let scene, camera, renderer, earth;
        let autoRotate = true; // Flag to determine whether the Earth should auto-rotate or be manually rotated
        const zoomThreshold = 1.5; // Threshold scale for switching between auto and manual rotation

        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Earth
            let geometry = new THREE.SphereGeometry(1, 128, 128);
            let texture = new THREE.TextureLoader().load('/static/images/earth.png');
            let material = new THREE.MeshBasicMaterial({ map: texture });
            earth = new THREE.Mesh(geometry, material);
            scene.add(earth);

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Only auto-rotate if the flag is true
            if(autoRotate) {
                earth.rotation.y += 0.005;
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Handle mouse wheel event to zoom in and out
        document.addEventListener('wheel', onWheelScroll, false);

        function onWheelScroll(event) {
            // Define a scale factor to determine the speed of zooming in/out
            const scaleFactor = 0.01;

            // Adjust the scale of the Earth based on the scroll direction
            if (event.deltaY > 0) {
                // Zoom out
                earth.scale.x *= (1 + scaleFactor);
                earth.scale.y *= (1 + scaleFactor);
                earth.scale.z *= (1 + scaleFactor);
            } else {
                // Zoom in
                earth.scale.x *= (1 - scaleFactor);
                earth.scale.y *= (1 - scaleFactor);
                earth.scale.z *= (1 - scaleFactor);
            }

            // Check if the Earth's scale has passed the threshold
            if(earth.scale.x > zoomThreshold) {
                autoRotate = false;
            } else {
                autoRotate = true;
            }
        }

        // Mouse drag events for manual rotation
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        document.addEventListener('mousedown', function(e) {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        document.addEventListener('mousemove', function(e) {
            if(!isDragging || autoRotate) return;

            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;

            earth.rotation.y += deltaX * 0.01;
            earth.rotation.x += deltaY * 0.01;

            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        document.addEventListener('mouseup', function() {
            isDragging = false;
        });

    </script>
</body>
</html>
